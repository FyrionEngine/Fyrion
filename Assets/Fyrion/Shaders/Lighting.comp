#include "Fyrion://Shaders/Includes/PBR.inc"


struct DirectionalLight
{
	float4 direction;
	float4 color;
	float4 intensityIndirect;
};

struct LightingData
{
    float4x4            viewInverse;
    float4x4            projInverse;
    float4              skyColor;
    float4              viewPos;
    DirectionalLight    directionalLight[4];
    uint                directionalLightCount;
};

Texture2D               gbufferColorMetallic    : register(t0);
Texture2D               gbufferNormalRoughness  : register(t1);
Texture2D               gBufferPositionAO       : register(t2);

Texture2D<float>        depthTex                : register(t3);
Texture2D               sky                     : register(t4);
RWTexture2D<float4>     lightColor              : register(u5);
SamplerState            samplerState            : register(s6);
TextureCube<float4>     diffuseIrradiance       : register(t7);

ConstantBuffer<LightingData> data               : register(b8);


float2 SampleSphericalMap(float3 v)
{
    const float2 invAtan = float2(0.1591, 0.3183);
    float2 uv = float2(atan2(v.z, v.x), asin(v.y));
    uv *= invAtan;
    uv += 0.5;
    uv *= -1.0;
    return uv;
}

[numthreads(16, 16, 1)]
void MainCS(in uint2 px : SV_DispatchThreadID)
{
    float2 screenSize;
    lightColor.GetDimensions(screenSize.x, screenSize.y);

    const float2 uv     = (float2(px) + 0.5) / screenSize;
    const float depth   = depthTex[px];

    if (depth == 1.0)
    {
        float2 d            = uv * 2.0 - 1.0;
        float4 target       = mul(data.projInverse, float4(d.x, d.y * -1.0, 1, 1));
        float4 direction    = mul(data.viewInverse, float4(normalize(target.xyz), 0));

        float3 output = sky.SampleLevel(samplerState, SampleSphericalMap(direction.xyz), 0).rgb * data.skyColor.rgb;


        // HDR tonemapping
        output = output / (output + 1.0);
        // gamma correct
        output = pow(output, 1.0/2.2);

        lightColor[px] = float4(output, 1.0);

        return;
    }

    float3  baseColor   = gbufferColorMetallic[px].rgb;
    float3  N           = gbufferNormalRoughness[px].rgb;
    float   metallic    = gbufferColorMetallic[px].a;
    float   roughness   = gbufferNormalRoughness[px].a;
    float3  fragPos     = gBufferPositionAO[px].xyz;
    float3  ao          = gBufferPositionAO[px].a;

	float3 V = normalize(data.viewPos.xyz - fragPos);

    float3 F0 = 0.04;
    F0 = lerp(F0, baseColor, metallic);

    float3 directLightColor = 0.0;
    float indirectMultiplier = 1.0;

    if (data.directionalLightCount > 0)
    {
        float shadow = 0.0;

        DirectionalLight light = data.directionalLight[0];
        indirectMultiplier = light.intensityIndirect.y;

        float3 L = normalize(light.direction.xyz);
        float3 H = normalize(V + L);

        // Cook-Torrance BRDF
        float  NDF  = DistributionGGX(N, H, roughness);
        float  G    = GeometrySmith(N, V, L, roughness);
        float3 F    = FresnelSchlick(clamp(dot(H, V), 0.0, 1.0), F0);

        float3 numerator    = NDF * G * F;
        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;
        float3 specular = numerator / denominator;

        float3 kD = 1.0 - F;
        kD *= 1.0 - metallic;
        float NdotL = max(dot(N, L), 0.0);

        float3 directLight = (kD * (baseColor / PI) + specular) * light.intensityIndirect.x * NdotL;
        directLightColor += directLight * (1.0 - shadow);
    }


    float3 indirectLight = 0.0;
    float3 irradiance = diffuseIrradiance.Sample(samplerState, N).rgb;

    indirectLight = baseColor * (irradiance * indirectMultiplier);
    indirectLight = directLightColor + indirectLight * 1.0 / PI;

    float3 finalColor = indirectLight;

    // HDR tonemapping
    finalColor = finalColor / (finalColor + 1.0);
    // gamma correct
    finalColor = pow(finalColor, 1.0/2.2);

    lightColor[px] = float4(finalColor, 1.0);
}