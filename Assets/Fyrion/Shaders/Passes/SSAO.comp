#define SSAO_KERNEL_ARRAY_SIZE 64
#define SSAO_KERNEL_SIZE 64
#define SSAO_RADIUS 0.5

struct UBOSSAOKernel
{
	float4 samples[SSAO_KERNEL_ARRAY_SIZE];
};

struct PushConst
{
	float4x4 projection;
	float4x4 view;
};

Texture2D           texturePositionDepth    : register(t0);
Texture2D           textureNormal           : register(t1);
Texture2D           ssaoNoiseTexture        : register(t2);
SamplerState        ssaoNoiseSampler        : register(s3);
RWTexture2D<float>  ssaoTexture             : register(u4);


ConstantBuffer<UBOSSAOKernel>  uboSSAOKernel: register(b5);
SamplerState                   colorSampler : register(s7);

[[vk::push_constant]] PushConst pushConst;

[numthreads(16, 16, 1)]
void MainCS(in uint2 px : SV_DispatchThreadID)
{

	int2 outDim;
	ssaoTexture.GetDimensions(outDim.x, outDim.y);

    const float2 uv = (float2(px) + 0.5) / outDim.xy;

    // Get G-Buffer values
	float3 fragPos = texturePositionDepth.Sample(colorSampler,  uv).rgb;

	fragPos = mul(pushConst.view, float4(fragPos, 1.0)).xyz;

	float3 normal  = normalize( mul(pushConst.view,  float4(textureNormal.Sample(colorSampler,  uv).rgb, 1.0)).xyz  * 2.0 - 1.0);

	// Get a random vector using a noise lookup
	int2 texDim;
	texturePositionDepth.GetDimensions(texDim.x, texDim.y);
	int2 noiseDim;
	ssaoNoiseTexture.GetDimensions(noiseDim.x, noiseDim.y);

	const float2 noiseUV = float2(float(texDim.x)/float(noiseDim.x), float(texDim.y)/(noiseDim.y)) * uv;

	float3 randomVec     = normalize(ssaoNoiseTexture.Sample(ssaoNoiseSampler, noiseUV).xyz) * 2.0 - 1.0;

	// Create TBN matrix
	float3 tangent      = normalize(randomVec - normal * dot(randomVec, normal));
	float3 bitangent    = cross(tangent, normal);
	float3x3 TBN        = transpose(float3x3(tangent, bitangent, normal));

	// Calculate occlusion value
	float occlusion = 0.0f;
	for(int i = 0; i < SSAO_KERNEL_SIZE; i++)
	{
		float3 samplePos = mul(TBN, uboSSAOKernel.samples[i].xyz);
		samplePos = fragPos + samplePos * SSAO_RADIUS;

		// project
		float4 offset = float4(samplePos, 1.0f);
		offset = mul(pushConst.projection, offset);
		offset.xyz /= offset.w;
		offset.xyz = offset.xyz * 0.5f + 0.5f;

        float4 samplePoss = float4(texturePositionDepth.Sample(colorSampler, offset.xy).xyz, 1.0);
        samplePoss = mul(pushConst.view, samplePoss);
        float sampleDepth = samplePoss.z;

//        float bias = 0.005;

		float rangeCheck = smoothstep(0.0f, 1.0f, SSAO_RADIUS / abs(fragPos.z - sampleDepth));
		occlusion += (sampleDepth >= samplePos.z ? 1.0f : 0.0f) * rangeCheck;
	}
	ssaoTexture[px] = 1.0 - (occlusion / float(SSAO_KERNEL_SIZE));
}